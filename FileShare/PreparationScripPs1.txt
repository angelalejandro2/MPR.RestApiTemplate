param(
    [Parameter(Mandatory = $true)]
    [string]$SourceName,            # Ej: MPR.RestApiTemplate

    [Parameter(Mandatory = $true)]
    [string]$ShortName,             # Ej: mprapi

    [Parameter(Mandatory = $true)]
    [string]$Identity,              # Ej: TuEmpresa.MPR.RestApiTemplate

    [Parameter(Mandatory = $false)]
    [string]$OutputPath = "./output",

    [Parameter(Mandatory = $false)]
    [string[]]$Exclude = @("MPR.RestApiTemplate.Vsix", ".git", ".gitignore")
)

$TempPath = "./template_tmp"

function Prepare-TempDirectory {
    Write-Host "üìÇ Preparando carpeta temporal '$TempPath'..."

    if (Test-Path $TempPath) {
        Remove-Item -Recurse -Force $TempPath
    }
    New-Item -ItemType Directory -Path $TempPath | Out-Null

    Get-ChildItem -Recurse -Force |
        Where-Object {
            $excludeMatch = $false
            foreach ($pattern in $Exclude) {
                if ($_.FullName -like "*$pattern*") { $excludeMatch = $true; break }
            }
            return !$excludeMatch
        } |
        Copy-Item -Destination { Join-Path $TempPath $_.FullName.Substring((Get-Location).Path.Length + 1) } -Recurse -Force
}

function Clean-Directory {
    Write-Host "üßπ Limpiando archivos innecesarios en '$TempPath'..."
    Get-ChildItem -Path $TempPath -Recurse -Include bin, obj, .vs, .vscode, TestResults | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
    Get-ChildItem -Path $TempPath -Recurse -Include *.user, *.suo, launchSettings.json | Remove-Item -Force -ErrorAction SilentlyContinue
}

function Replace-Names {
    Write-Host "‚úèÔ∏è Reemplazando '$SourceName' ‚Üí '{{SolutionName}}' en archivos y nombres..."

    $allFiles = Get-ChildItem -Path $TempPath -Recurse -File -Include *.cs, *.csproj, *.sln, *.json, *.cshtml, *.config, *.yml

    foreach ($file in $allFiles) {
        (Get-Content $file.FullName) -replace $SourceName, "{{SolutionName}}" | Set-Content $file.FullName
    }

    # Renombrar carpetas
    Get-ChildItem -Path $TempPath -Recurse -Directory |
        Where-Object { $_.Name -like "*$SourceName*" } |
        ForEach-Object {
            $newName = $_.Name -replace [regex]::Escape($SourceName), "{{SolutionName}}"
            Rename-Item -Path $_.FullName -NewName $newName -Force
        }

    # Renombrar archivos
    Get-ChildItem -Path $TempPath -Recurse -File |
        Where-Object { $_.Name -like "*$SourceName*" } |
        ForEach-Object {
            $newName = $_.Name -replace [regex]::Escape($SourceName), "{{SolutionName}}"
            Rename-Item -Path $_.FullName -NewName $newName -Force
        }
}

function Move-To-Output {
    if (Test-Path $OutputPath) {
        Remove-Item -Recurse -Force $OutputPath
    }

    Write-Host "üì¶ Copiando contenido procesado a '$OutputPath'..."
    Copy-Item -Path "$TempPath\*" -Destination $OutputPath -Recurse -Force
}

function Pack-Nuget {
    Write-Host "üì¶ Generando paquete NuGet..."
    dotnet new uninstall $OutputPath -ea SilentlyContinue | Out-Null
    dotnet new install $OutputPath

    $templateCsproj = Get-ChildItem -Path $OutputPath -Recurse -Filter "*.csproj" | Select-Object -First 1
    if ($null -ne $templateCsproj) {
        dotnet pack $templateCsproj.FullName -o "$OutputPath\nuget"
        Write-Host "‚úÖ NuGet package creado en '$OutputPath\nuget'"
    } else {
        Write-Warning "‚ö†Ô∏è No se encontr√≥ .csproj para empacar. Aseg√∫rate de tener un archivo .csproj v√°lido si deseas generar un .nupkg."
    }
}

function Clean-Temp {
    Write-Host "üßΩ Eliminando carpeta temporal..."
    Remove-Item -Recurse -Force $TempPath
}

# === EJECUCI√ìN ===

$ErrorActionPreference = "Stop"

Prepare-TempDirectory
Clean-Directory
Replace-Names
Move-To-Output
Pack-Nuget
Clean-Temp

Write-Host "`n‚úÖ Plantilla lista en '$OutputPath'"
Write-Host "Puedes probarla con:"
Write-Host "   dotnet new $ShortName -n MiProyecto"