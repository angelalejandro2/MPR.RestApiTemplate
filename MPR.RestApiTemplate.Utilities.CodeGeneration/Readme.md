# Scaffolding command sample
## Sql Server Database
``` powershell
.\ScaffoldDatabase.ps1 -ConnectionString "Server=(localdb)\mssqllocaldb;Database=Northwind;Encrypt=False;Trusted_Connection=True;MultipleActiveResultSets=True;" -DbProvider SqlServer
```
## Oracle Database
``` powershell
.\ScaffoldDatabase.ps1 -ConnectionString "Data Source=localhost:1521/XEPDB1;User Id=hr;Password=hr;" -DbProvider Oracle
```

# Instrucciones

## Crear una nueva solucion
- Puede crear una nueva solucion utilizando cualquiera de estos metodos:
    - Seleccionando crear un nuevo proyecto en Visual Studio y seleccionar el proyecto MPR Rest Api Template
    - Ejecutando el siguiente comando por CLI:
        ```sh
        dotnet new mpr-rest-api -n MySolutionName
        ```
- Una vez creada la solucion necesita generar las entidades en el directorio Entities del proyecto Domain y el DbContext en el directorio Context del proyecto Infrastructure. Si es una base de datos que se esta creando nueva va a utilizar un enfoque Code First. Si la base de datos ya existe, va a crear las entidades y el DbContext mediante scaffolding. Una vez se haga el scaffolding se continua en Code First.

## Agregar bases de datos existentes mediante scaffolding

1. Verificar que el proyecto de Infrastructure haga Build
    - Solo el proyecto Infrastructure, no la solucion completa.
1. Ejecutar scaffold utilizando algunos de los comandos al principio de este documento de acuerdo al proveedor de su base de datos.
1. El proceso de Scaffolding va a generar el DbContext en el directorio Context del proyecto Domain. Este DbContext se tiene que mover al directorio context dentro del proyecto Infrastructure. 
    - Importante que elimine la copia del DbContext del proyecto Domain una vez lo mueva a Infrastructure. 
1. Una vez mueva el DbContext, tiene que abrirlo y actualizar el namespace para que refleje el correcto de acuerdo a la ubicacion. Por ultimo, si esta usando una base de datos SQL Server, va a colocar el Atributo DbProvider a la clase:
```c#
namespace MPR.RestApiTemplate.Infrastructure.Context;

[DbProvider(DbProvider.SqlServer)]
public partial class NorthwindContext : DbContext
{
    ...
```
1. Agregar el atributo DatabaseGenerated para aquellas propiedades [Key] que son autogeneradas en la base de datos. Si es SQL Server y se esta generando por Identity va a utilizar [DatabaseGenerated(DatabaseGeneratedOption.Identity)]. Para Oracle, si esta utilizando una secuencia y nextval en el default va a utilizar [DatabaseGenerated(DatabaseGeneratedOption.Computed)]. Usar estos queries para identificar las tablas que tengan columnas autogeneradas.
	``` SQL
    -- SQL Server
    SELECT 
        C.TABLE_NAME, 
        C.COLUMN_NAME 
    FROM 
        INFORMATION_SCHEMA.COLUMNS C
    JOIN 
        INFORMATION_SCHEMA.TABLES T
    ON 
        C.TABLE_NAME = T.TABLE_NAME AND C.TABLE_SCHEMA = T.TABLE_SCHEMA
    WHERE 
        COLUMNPROPERTY(OBJECT_ID(C.TABLE_SCHEMA + '.' + C.TABLE_NAME), C.COLUMN_NAME, 'IsIdentity') = 1 
        AND T.TABLE_TYPE = 'BASE TABLE'
	```
    ``` Oracle
    -- Query to find tables with autogenerated primary keys (IDENTITY or SEQUENCE-based) in Oracle XE 21
    SELECT 
        t.table_name,
        c.column_name AS pk_column,
        CASE 
            WHEN c.identity_column = 'YES' THEN 'IDENTITY'
            WHEN EXISTS (
                SELECT 1 
                FROM user_sequences s
                WHERE DBMS_METADATA.GET_DDL('TABLE', t.table_name) LIKE '%' || c.column_name || '%' || s.sequence_name || '%NEXTVAL%'
            ) THEN 'SEQUENCE'
            ELSE NULL
        END AS generation_type
    FROM 
        user_tables t
    JOIN 
        user_constraints pk ON t.table_name = pk.table_name AND pk.constraint_type = 'P'
    JOIN 
        user_cons_columns pkcol ON pk.constraint_name = pkcol.constraint_name
    JOIN 
        user_tab_columns c ON pkcol.table_name = c.table_name AND pkcol.column_name = c.column_name
    WHERE 
        c.identity_column = 'YES' 
        OR EXISTS (
            SELECT 1 
            FROM user_sequences s
            WHERE DBMS_METADATA.GET_DDL('TABLE', t.table_name) LIKE '%' || c.column_name || '%' || s.sequence_name || '%NEXTVAL%'
        )
    ORDER BY 
        t.table_name, c.column_name;
    ```
Ya en este punto podemos ejecutar la generacion de codigo.

## Generacion de codigo
1. Una vez tenga las entidades generadas y el (o los) DbContext creados, vamos a ejecutar el powershell CodeGeneration.ps1. Para esto vamos a ejecutar los siguientes comandos desde el Package Manager Console de VS:
    ```ps1
    cd {SolutionName}.CodeGeneration #Replace {solutionName} with the actual name of your solution

    .\CodeGeneration.ps1
    ```
1. Va a ver en pantalla que se van a ir ejecutando una serie de instrucciones que van a ir generando el codigo por partes.
1. Una vez el codigo este generado va a actulizar los connection strings. Para esto:
    1. Busque el archivo DbContextRegistration.cs en el directorio Startup > Generated en el proyecto Api. En el metodo ConfigureDbContexts() va a poder ver los nombres de los connection strings para cada DbContext que haya creado.
    1. Va abrir el archivo appsettings.json y va a crear las connection strings que hagan falta de acuerdo a lo que se ecnuentre en el archivo DbContextRegistration.cs
1. Ya en este punto puede hacer Build de la solucion completa y ejecutarla.

## Crear las migraciones luego de un scaffolding, cambios a entidades o DbContexts.
1. Ejecutar MigrationCreate.ps1 desde el package manager console en VS.
1. La ejecucion de este script va a crear un archivo de migracion que va a estar ubicado en el directorio Migrations del proyecto Infrastructure.
    - **NOTA**: Cuando se hace crea una migracion luego de un scaffolding, hay que limpiar el codigo de la migracion para evitar que Entity Framework trate de crear objetos que ya existen. Para esto va a abrir el archivo de migracion y va a eliminar el codigo que esta dentro de los metodos up y down.
1. Para aplicar las migraciones a la base de datos, ejecute el script MigrationApply.ps1 desde el package manager console en VS

## Como extender el codigo autogenerado
El codigo autogenerado crea clases parciales con metodos virtuales siempre que sea posible. Esto se hace para que los desarrolladore no modifiquen los archivos autogenerados pero que tengan la flexibilidad de extenderlo para implementar sus propias logicas.

### Extender un servicio para implementar logica de negocios
En el proyecto Application, hay un directorio con el nombre Services. Dentro van las clases que representan los servicios de la aplicacion. En estos servicios es donde se coloca la logica de negocios, la logica de mapping de las entidades con los DTOs y la logica de persistencia, o sea, la interaccion con el unit of work y los repositorios. 

Puede crear servicios nuevos o simplemente extender alguno de los ya existentes. La decision depende de que logica quiere implementar y a que entidad (si alguna) le pertenece la logica.

#### Para extender un servicio:
1. Identifique el servicio que quiere extender. Ejemplo: CustomerService.cs (localizado bajo el directorio Services > Generated en el proyecto Application)
1. En el directorio Services, cree un nuevo archivo de clase con el mismo nombre del que quiere extender. 
1. Cuando abra el archivo, asegurece de cambiar la clase a que se parcial utilizando el keyword partial. 
1. Ya en este punto puede crear los metodos adicionales que desee.

#### Para hacer override de un metodo existente en un servicio
1. Identifique el servicio que contiene el metodo que quiere hacerle override. Ejemplo CustomerService.cs
1. En el directorio Services, cree un nuevo archivo con el nombre {Entity}ExtendedService.cs. Por ejemplo CustomerExtendedService.cs
1. Cuando abra el archivo, haga que la clase herede de la clase que contiene el metodo que quiere hacer override
    ```c#
        public class CustomerExtendedService: CustomerService
    ```
1. Haga override del metodo deseado utilizando el keyword override

#### Para extender un controller:
1. Identifique el controller que quiere extender. Ejemplo: CustomerController.cs (localizado bajo el directorio Controller > Generated del proyecto Api)
1. En el directorio Controllers, cree un nuevo archivo de clase con el mismo nombre del que quiere extender. 
1. Cuando abra el archivo, asegurece de cambiar la clase a que se parcial utilizando el keyword partial. 
1. En el caso de los controllers, es importante que no coloque los atributos de clase [ApiController], [ApiVersion] ni [Route] en el controller que extiende para evitar problemas con las rutas y duplicidad en la docuemntacion de especificaciones de API.
1. Ya en este punto puede crear los metodos adicionales que desee.

#### Para hacer override de un metodo existente en un controller
1. Identifique el servicio que contiene el metodo que quiere hacerle override. Ejemplo CustomerController.cs
1. En el directorio Controllers, cree un nuevo archivo con el nombre {Entity}ExtendedController.cs. Por ejemplo CustomerExtendedService.cs
1. Cuando abra el archivo, haga que la clase herede de la clase que contiene el metodo que quiere hacer override
    ```c#
        public class CustomerExtendedController: CustomerController
    ```
1. Haga override del metodo deseado utilizando el keyword override

## Consideraciones
- Cuando se crea la solucion inicial, la misma no compila debido a referencias que necesita y que son autogeneradas. 
- Una vez este generado toda la parte de las entidades y los DbContexts, la mayoria del trabajo de implementar logica de negocios se concentra en el proyecto Application y su exposicion en el proyecto API. Los proyectos Domain e Infrastructure no se tocan a menos que hayan cambios a nivel de estructura de entidades o que haya una logca de negocios especifica de dominio. 