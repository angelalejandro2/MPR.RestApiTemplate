<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ include file="..\T4Includes\ConfigHelper.ttinclude" #>

<#
    #nullable enable
    
    // Clase simple para configuración manual (hardcoded)
    class EntityDtoConfig
    {
        public string DtoName { get; set; }
        public string CreateDtoName { get; set; }
        public string UpdateDtoName { get; set; }
        
        public EntityDtoConfig(string dtoName, string createDtoName, string updateDtoName)
        {
            DtoName = dtoName;
            CreateDtoName = createDtoName;
            UpdateDtoName = updateDtoName;
        }
    }
    
    // Diccionario de configuración manual
    var customDtoNames = new Dictionary<string, EntityDtoConfig>
    {
        // Esta es la entidad que queremos personalizar
        { "AlphabeticalListOfProducts", new EntityDtoConfig(
            "ListOfProductsDto", 
            "CreateListOfProductsDto", 
            "UpdateListOfProductsDto"
        )}
    };
    
    // Función para obtener el nombre del DTO
    string GetDtoName(string entityName)
    {
        if (customDtoNames.TryGetValue(entityName, out var config))
        {
            System.Diagnostics.Debug.WriteLine($"Using custom DTO name for {entityName}: {config.DtoName}");
            return config.DtoName;
        }
        
        return $"{entityName}Dto";
    }
    
    // Función para obtener el nombre del CreateDTO
    string GetCreateDtoName(string entityName)
    {
        if (customDtoNames.TryGetValue(entityName, out var config))
        {
            System.Diagnostics.Debug.WriteLine($"Using custom CreateDTO name for {entityName}: {config.CreateDtoName}");
            return config.CreateDtoName;
        }
        
        return $"{entityName}CreateDto";
    }
    
    // Función para obtener el nombre del UpdateDTO
    string GetUpdateDtoName(string entityName)
    {
        if (customDtoNames.TryGetValue(entityName, out var config))
        {
            System.Diagnostics.Debug.WriteLine($"Using custom UpdateDTO name for {entityName}: {config.UpdateDtoName}");
            return config.UpdateDtoName;
        }
        
        return $"{entityName}UpdateDto";
    }
    
    // Función para generar el contenido de la clase DTO
    string GenerateDtoClass(string className, List<(string Type, string Name, bool IsKey, string? DbGenerated, bool IsEntityReference)> properties)
    {
        string dtoName = GetDtoName(className);
        
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("// Autogenerated Code - Do not modify");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
        sb.AppendLine("");
        sb.AppendLine("namespace MPR.RestApiTemplate.Application.DTOs");
        sb.AppendLine("{");
        sb.AppendLine($"    public class {dtoName}");
        sb.AppendLine("    {");
        
        foreach (var prop in properties)
        {
            if (prop.IsKey)
            {
                sb.AppendLine("        [Key]");
            }
            if (!string.IsNullOrEmpty(prop.DbGenerated))
            {
                sb.AppendLine($"        {prop.DbGenerated}");
            }
            sb.AppendLine($"        public {prop.Type} {prop.Name} {{ get; set; }}");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    // Función para generar el contenido de la clase CreateDto
    string GenerateCreateDtoClass(string className, List<(string Type, string Name, bool IsKey, string? DbGenerated, bool IsEntityReference)> properties)
    {
        string createDtoName = GetCreateDtoName(className);
        
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("// Autogenerated Code - Do not modify");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
        sb.AppendLine("");
        sb.AppendLine("namespace MPR.RestApiTemplate.Application.DTOs");
        sb.AppendLine("{");
        sb.AppendLine($"    public class {createDtoName}");
        sb.AppendLine("    {");
        
        foreach (var prop in properties.Where(p => string.IsNullOrEmpty(p.DbGenerated) && !p.IsEntityReference))
        {
            sb.AppendLine($"        public {prop.Type} {prop.Name} {{ get; set; }}");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    // Función para generar el contenido de la clase UpdateDto
    string GenerateUpdateDtoClass(string className, List<(string Type, string Name, bool IsKey, string? DbGenerated, bool IsEntityReference)> properties)
    {
        string updateDtoName = GetUpdateDtoName(className);
        
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("// Autogenerated Code - Do not modify");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
        sb.AppendLine("");
        sb.AppendLine("namespace MPR.RestApiTemplate.Application.DTOs");
        sb.AppendLine("{");
        sb.AppendLine($"    public class {updateDtoName}");
        sb.AppendLine("    {");
        
        foreach (var prop in properties.Where(p => !p.IsEntityReference && (string.IsNullOrEmpty(p.DbGenerated) || p.IsKey)))
        {
            sb.AppendLine($"        public {prop.Type} {prop.Name} {{ get; set; }}");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    // Directorio donde se encuentran las entidades
    string entitiesPath = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), @"..\..\MPR.RestApiTemplate.Domain\Entities");
    
    // Directorio donde se guardarán los DTOs generados
    string outputPath = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), @"..\..\MPR.RestApiTemplate.Application\Dtos\GeneratedDtos");
    
    // Crear el directorio de salida si no existe
    if (!Directory.Exists(outputPath))
    {
        Directory.CreateDirectory(outputPath);
    }
    
    var entityFiles = Directory.GetFiles(entitiesPath, "*.cs");
    var entityNames = entityFiles.Select(f => Path.GetFileNameWithoutExtension(f)).ToHashSet();

    // Mostrar información de depuración
    System.Diagnostics.Debug.WriteLine($"Found {entityFiles.Length} entity files");
    foreach (var name in entityNames)
    {
        System.Diagnostics.Debug.WriteLine($"Entity: {name}");
    }

    foreach (var file in entityFiles)
    {
        var className = Path.GetFileNameWithoutExtension(file);
        System.Diagnostics.Debug.WriteLine($"Processing entity: {className}");
        
        var lines = File.ReadAllLines(file);

        var properties = new List<(string Type, string Name, bool IsKey, string? DbGenerated, bool IsEntityReference)>();

        bool nextIsKey = false;
        string? nextDatabaseGenerated = null;
        
        foreach (var line in lines)
        {
            var trimmed = line.Trim();

            if (trimmed.StartsWith("[Key]"))
            {
                nextIsKey = true;
                continue;
            }

            if (trimmed.StartsWith("[DatabaseGenerated"))
            {
                nextDatabaseGenerated = trimmed;
                continue;
            }

            if (trimmed.StartsWith("public") && trimmed.Contains("{ get;") && !trimmed.Contains("class"))
            {
                var cleanLine = trimmed.Replace("virtual", "").Trim();
                var parts = cleanLine.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);

                if (parts.Length >= 3)
                {
                    string rawType = parts[1];
                    string rawName = parts[2].Split(new[] { '{', ';' }, StringSplitOptions.RemoveEmptyEntries)[0].Trim();

                    string type = rawType.EndsWith("?") ? rawType : rawType;

                    string modelType;
                    string baseType = type.TrimEnd('?');
                    bool isEntityReference = false;

                    var match = Regex.Match(type, @"^(?<collection>\w+)<(?<inner>\w+)>$");
                    if (match.Success)
                    {
                        var collectionType = match.Groups["collection"].Value;
                        var innerType = match.Groups["inner"].Value;
                        isEntityReference = entityNames.Contains(innerType);
                        
                        // Usar el nombre de DTO personalizado si disponible
                        string mappedInnerType = isEntityReference ? GetDtoName(innerType) : innerType;
                        modelType = $"{collectionType}<{mappedInnerType}>";
                    }
                    else
                    {
                        isEntityReference = entityNames.Contains(baseType);
                        
                        // Usar el nombre de DTO personalizado si disponible
                        modelType = isEntityReference ? GetDtoName(baseType) : type;
                    }

                    bool isKey = nextIsKey;
                    string? dbGenerated = nextDatabaseGenerated;

                    properties.Add((modelType, rawName, isKey, dbGenerated, isEntityReference));

                    nextIsKey = false;
                    nextDatabaseGenerated = null;
                }
            }
        }

        // Obtener el nombre del DTO
        string dtoName = GetDtoName(className);
        System.Diagnostics.Debug.WriteLine($"DTO name for {className}: {dtoName}");
        
        // Generar el archivo para la clase DTO principal
        string dtoContent = GenerateDtoClass(className, properties);
        string dtoFileName = $"{dtoName}.cs";
        string dtoFilePath = Path.Combine(outputPath, dtoFileName);
        
        // Siempre escribir el archivo (para pruebas)
        File.WriteAllText(dtoFilePath, dtoContent);
        System.Diagnostics.Debug.WriteLine($"Generated DTO file: {dtoFilePath}");
        
        // Si la entidad tiene clave primaria, crear los DTOs adicionales (Create y Update)
        if (properties.Any(p => p.IsKey))
        {
            // Obtener el nombre del CreateDTO
            string createDtoName = GetCreateDtoName(className);
            System.Diagnostics.Debug.WriteLine($"CreateDTO name for {className}: {createDtoName}");
            
            // Generar el archivo para CreateDto
            string createDtoContent = GenerateCreateDtoClass(className, properties);
            string createDtoFileName = $"{createDtoName}.cs";
            string createDtoFilePath = Path.Combine(outputPath, createDtoFileName);
            
            // Siempre escribir el archivo (para pruebas)
            File.WriteAllText(createDtoFilePath, createDtoContent);
            System.Diagnostics.Debug.WriteLine($"Generated CreateDTO file: {createDtoFilePath}");
            
            // Obtener el nombre del UpdateDTO
            string updateDtoName = GetUpdateDtoName(className);
            System.Diagnostics.Debug.WriteLine($"UpdateDTO name for {className}: {updateDtoName}");
            
            // Generar el archivo para UpdateDto
            string updateDtoContent = GenerateUpdateDtoClass(className, properties);
            string updateDtoFileName = $"{updateDtoName}.cs";
            string updateDtoFilePath = Path.Combine(outputPath, updateDtoFileName);
            
            // Siempre escribir el archivo (para pruebas)
            File.WriteAllText(updateDtoFilePath, updateDtoContent);
            System.Diagnostics.Debug.WriteLine($"Generated UpdateDTO file: {updateDtoFilePath}");
        }
    }
#>
// Esta plantilla ha generado archivos DTO individuales para cada entidad.
// Los archivos generados se encuentran en la carpeta GeneratedDTOs.
// Nota: Para fines de depuración, se han sobrescrito los archivos existentes.