<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\T4Includes\MprCodegenParser.ttinclude" #>
<#@ output extension=".generated.cs" #>
<#
    // Crear una instancia del MprCodegenParser para leer la configuración
    var parser = new MprCodegenParser(Host.TemplateFile, @"..\mpr.codegen.json");
    
    // Función para obtener el nombre personalizado de la entidad desde mpr.codegen.json
    string GetCustomEntityName(string entityName, MprCodegenParser parser)
    {
        try
        {
            // Obtenemos los nombres de DTO para aprovechar la lógica que ya existe en el parser
            var (dtoName, _, _) = parser.GetDtoNames(entityName);
            
            // Extraer el nombre base de la entidad del nombre del DTO (quitando "Dto" del final)
            string customName = dtoName.EndsWith("Dto") ? dtoName.Substring(0, dtoName.Length - 3) : dtoName;
            
            return string.IsNullOrEmpty(customName) ? entityName : customName;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error al obtener nombre personalizado: {ex.Message}");
            return entityName;
        }
    }
    
    // Función para generar el contenido de la clase de servicio
    string GenerateServiceClass(string entityName, List<(string Type, string Name)> keyProperties, bool isKeyless, MprCodegenParser parser)
    {
        // Obtener el nombre personalizado de la entidad desde la configuración
        string customEntityName = GetCustomEntityName(entityName, parser);
        
        // Obtener los nombres de DTO configurados o por defecto
        var (dtoName, createDtoName, updateDtoName) = parser.GetDtoNames(entityName);
        
        var methodParams = string.Join(", ", keyProperties.Select(p => $"{p.Type} {char.ToLower(p.Name[0]) + p.Name.Substring(1)}"));
        var methodKeys = string.Join(", ", keyProperties.Select(p => char.ToLower(p.Name[0]) + p.Name.Substring(1)));
        
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("// Autogenerated Code - Do not modify");
        sb.AppendLine("using AutoMapper;");
        sb.AppendLine("using MPR.RestApiTemplate.Application.DTOs;");
        sb.AppendLine("using MPR.RestApiTemplate.Domain.Entities;");
        sb.AppendLine("using MPR.RestApiTemplate.Domain.Interfaces;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("");
        sb.AppendLine("namespace MPR.RestApiTemplate.Application.Services");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {customEntityName}Service");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly IUnitOfWork _unitOfWork;");
        sb.AppendLine("        private readonly IMapper _mapper;");
        sb.AppendLine("");
        sb.AppendLine($"        public {customEntityName}Service(IUnitOfWork unitOfWork, IMapper mapper)");
        sb.AppendLine("        {");
        sb.AppendLine("            _unitOfWork = unitOfWork;");
        sb.AppendLine("            _mapper = mapper;");
        sb.AppendLine("        }");
        sb.AppendLine("");
        sb.AppendLine($"        public virtual async Task<IEnumerable<{dtoName}>> GetAllAsync(params Expression<Func<{entityName}, object>>[] includes)");
        sb.AppendLine("        {");
        sb.AppendLine($"            var entities = await _unitOfWork.{entityName}Repository.GetAllAsync(includes);");
        sb.AppendLine($"            return _mapper.Map<IEnumerable<{dtoName}>>(entities);");
        sb.AppendLine("        }");
        
        if (!isKeyless && keyProperties.Count > 0)
        {
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task<{dtoName}> GetByIdAsync({methodParams}, params Expression<Func<{entityName}, object>>[] includes)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var entity = await _unitOfWork.{entityName}Repository.GetByIdAsync(new object[] {{ {methodKeys} }}, includes);");
            sb.AppendLine($"            return _mapper.Map<{dtoName}>(entity);");
            sb.AppendLine("        }");
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task DeleteAsync({methodParams})");
            sb.AppendLine("        {");
            sb.AppendLine($"            await _unitOfWork.{entityName}Repository.DeleteAsync({methodKeys});");
            sb.AppendLine("            await _unitOfWork.SaveChangesAsync();");
            sb.AppendLine("        }");
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task<{dtoName}> AddAsync({createDtoName} model)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var entity = _mapper.Map<{entityName}>(model);");
            sb.AppendLine($"            entity = await _unitOfWork.{entityName}Repository.AddAsync(entity);");
            sb.AppendLine("            await _unitOfWork.SaveChangesAsync();");
            sb.AppendLine($"            return _mapper.Map<{dtoName}>(entity);");
            sb.AppendLine("        }");
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task<{dtoName}> UpdateAsync({updateDtoName} model)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var entity = _mapper.Map<{entityName}>(model);");
            sb.AppendLine($"            entity = await _unitOfWork.{entityName}Repository.UpdateAsync(entity);");
            sb.AppendLine("            await _unitOfWork.SaveChangesAsync();");
            sb.AppendLine($"            return _mapper.Map<{dtoName}>(entity);");
            sb.AppendLine("        }");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    // Directorio donde se encuentran las entidades
    var entitiesPath = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), @"..\..\MPR.RestApiTemplate.Domain\Entities");
    
    // Directorio donde se guardarán los servicios generados
    string outputPath = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), @"..\..\MPR.RestApiTemplate.Application\Services\Generated");
    
    // Crear el directorio de salida si no existe
    if (!Directory.Exists(outputPath))
    {
        Directory.CreateDirectory(outputPath);
    }
    
    var files = Directory.GetFiles(entitiesPath, "*.cs");
    
    foreach (var file in files)
    {
        var entityName = Path.GetFileNameWithoutExtension(file);
        var lines = File.ReadAllLines(file);
        
        List<(string Type, string Name)> keyProperties = new();
        bool nextIsKey = false;
        bool isKeyless = lines.Any(l => l.Trim().StartsWith("[Keyless]"));
        
        foreach (var line in lines)
        {
            string trimmed = line.Trim();
            if (trimmed.StartsWith("[Key]"))
            {
                nextIsKey = true;
                continue;
            }
            if (nextIsKey && trimmed.StartsWith("public") && trimmed.Contains("{ get;") && !trimmed.Contains("class"))
            {
                var parts = trimmed.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length >= 3)
                {
                    string type = parts[1];
                    string name = parts[2];
                    if (name.Contains("{")) name = name.Substring(0, name.IndexOf("{"));
                    if (name.EndsWith(";")) name = name.Substring(0, name.Length - 1);
                    keyProperties.Add((type, name));
                }
                nextIsKey = false;
            }
        }
        
        // Obtener el nombre personalizado para el archivo de salida
        string customEntityName = GetCustomEntityName(entityName, parser);
        
        // Generar el contenido de la clase de servicio
        string serviceContent = GenerateServiceClass(entityName, keyProperties, isKeyless, parser);
        
        // Nombre del archivo de salida con el nombre personalizado
        string outputFileName = $"{customEntityName}Service.cs";
        string outputFilePath = Path.Combine(outputPath, outputFileName);
        
        // Escribir el archivo
        File.WriteAllText(outputFilePath, serviceContent);
    }
#>
// Esta plantilla ha generado clases de servicio individuales para cada entidad.
// Los archivos generados se encuentran en la carpeta GeneratedServices.
// Los nombres de DTOs personalizados se configuran en mpr.codegen.json