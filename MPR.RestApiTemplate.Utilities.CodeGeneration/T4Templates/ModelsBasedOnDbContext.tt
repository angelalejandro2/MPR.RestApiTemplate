<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.EntityFrameworkCore" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.EntityFrameworkCore" #>
<#@ import namespace="Microsoft.EntityFrameworkCore.Metadata" #>

// Auto-generado desde DbContexts en EF Core (.NET 9)

using System.ComponentModel.DataAnnotations;

namespace Your.Namespace.Models
{
<#
    // Ruta a tu ensamblado de infraestructura compilado
    string infraPath = Host.ResolvePath(@"..\MPR.RestApiTemplate.Infrastructure\bin\Debug\net9.0\MPR.RestApiTemplate.Infrastructure.dll");
    Assembly infraAssembly = Assembly.LoadFrom(infraPath);

    var dbContexts = infraAssembly.GetTypes()
        .Where(t => typeof(DbContext).IsAssignableFrom(t) && !t.IsAbstract)
        .ToList();

    foreach (var contextType in dbContexts)
    {
        DbContext context = null;
        try
        {
            context = (DbContext)Activator.CreateInstance(contextType);
        }
        catch
        {
            continue;
        }

        var model = context.Model;
        foreach (var entityType in model.GetEntityTypes())
        {
            var entityName = entityType.ClrType.Name;
            var modelName = entityName + "Model";

            var keyProperties = entityType.FindPrimaryKey()?.Properties.Select(p => p.Name).ToHashSet() ?? new HashSet<string>();
#>
    public class <#= modelName #>
    {
<#
            foreach (var property in entityType.GetProperties())
            {
                if (keyProperties.Contains(property.Name))
                {
#>        [Key]
<#
                }
#>        public <#= property.ClrType.FullName.Replace("+", ".") + (property.IsNullable && property.ClrType.IsValueType ? "?" : "") #> <#= property.Name #> { get; set; }
<#
            }
#>    }

<#
        }

        context.Dispose();
    }
#>
}

<#+
    string GetClrType(TypeUsage typeUsage)
    {
        string typeName = typeUsage.EdmType.Name;
        bool isNullable = typeUsage.Facets.Any(f => f.Name == "Nullable" && (bool)f.Value == true);

        switch (typeName)
        {
            case "String": return "string";
            case "Int32": return isNullable ? "int?" : "int";
            case "Int16": return isNullable ? "short?" : "short";
            case "Int64": return isNullable ? "long?" : "long";
            case "Boolean": return isNullable ? "bool?" : "bool";
            case "Decimal": return isNullable ? "decimal?" : "decimal";
            case "Double": return isNullable ? "double?" : "double";
            case "Single": return isNullable ? "float?" : "float";
            case "DateTime": return isNullable ? "DateTime?" : "DateTime";
            case "Byte": return isNullable ? "byte?" : "byte";
            case "Guid": return isNullable ? "Guid?" : "Guid";
            default: return typeName;
        }
    }
#>