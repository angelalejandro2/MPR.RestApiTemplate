<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#
    // Función para generar el contenido de la clase de servicio
    string GenerateServiceClass(string entityName, List<(string Type, string Name)> keyProperties, bool isKeyless)
    {
        var methodParams = string.Join(", ", keyProperties.Select(p => $"{p.Type} {char.ToLower(p.Name[0]) + p.Name.Substring(1)}"));
        var methodKeys = string.Join(", ", keyProperties.Select(p => char.ToLower(p.Name[0]) + p.Name.Substring(1)));
        
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("// Autogenerated Code - Do not modify");
        sb.AppendLine("using AutoMapper;");
        sb.AppendLine("using MPR.RestApiTemplate.Application.DTOs;");
        sb.AppendLine("using MPR.RestApiTemplate.Domain.Entities;");
        sb.AppendLine("using MPR.RestApiTemplate.Domain.Interfaces;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("");
        sb.AppendLine("namespace MPR.RestApiTemplate.Application.Services");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {entityName}Service");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly IUnitOfWork _unitOfWork;");
        sb.AppendLine("        private readonly IMapper _mapper;");
        sb.AppendLine("");
        sb.AppendLine($"        public {entityName}Service(IUnitOfWork unitOfWork, IMapper mapper)");
        sb.AppendLine("        {");
        sb.AppendLine("            _unitOfWork = unitOfWork;");
        sb.AppendLine("            _mapper = mapper;");
        sb.AppendLine("        }");
        sb.AppendLine("");
        sb.AppendLine($"        public virtual async Task<IEnumerable<{entityName}Dto>> GetAllAsync(params Expression<Func<{entityName}, object>>[] includes)");
        sb.AppendLine("        {");
        sb.AppendLine($"            var entities = await _unitOfWork.{entityName}Repository.GetAllAsync(includes);");
        sb.AppendLine($"            return _mapper.Map<IEnumerable<{entityName}Dto>>(entities);");
        sb.AppendLine("        }");
        
        if (!isKeyless && keyProperties.Count > 0)
        {
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task<{entityName}Dto> GetByIdAsync({methodParams}, params Expression<Func<{entityName}, object>>[] includes)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var entity = await _unitOfWork.{entityName}Repository.GetByIdAsync(new object[] {{ {methodKeys} }}, includes);");
            sb.AppendLine($"            return _mapper.Map<{entityName}Dto>(entity);");
            sb.AppendLine("        }");
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task DeleteAsync({methodParams})");
            sb.AppendLine("        {");
            sb.AppendLine($"            await _unitOfWork.{entityName}Repository.DeleteAsync({methodKeys});");
            sb.AppendLine("            await _unitOfWork.SaveChangesAsync();");
            sb.AppendLine("        }");
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task<{entityName}Dto> AddAsync({entityName}CreateDto model)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var entity = _mapper.Map<{entityName}>(model);");
            sb.AppendLine($"            entity = await _unitOfWork.{entityName}Repository.AddAsync(entity);");
            sb.AppendLine("            await _unitOfWork.SaveChangesAsync();");
            sb.AppendLine($"            return _mapper.Map<{entityName}Dto>(entity);");
            sb.AppendLine("        }");
            sb.AppendLine("");
            sb.AppendLine($"        public virtual async Task<{entityName}Dto> UpdateAsync({entityName}UpdateDto model)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var entity = _mapper.Map<{entityName}>(model);");
            sb.AppendLine($"            entity = await _unitOfWork.{entityName}Repository.UpdateAsync(entity);");
            sb.AppendLine("            await _unitOfWork.SaveChangesAsync();");
            sb.AppendLine($"            return _mapper.Map<{entityName}Dto>(entity);");
            sb.AppendLine("        }");
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    // Directorio donde se encuentran las entidades
    var entitiesPath = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), @"..\..\MPR.RestApiTemplate.Domain\Entities");
    
    // Directorio donde se guardarán los servicios generados
    string outputPath = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), @"..\..\MPR.RestApiTemplate.Application\Services\Generated");
    
    // Crear el directorio de salida si no existe
    if (!Directory.Exists(outputPath))
    {
        Directory.CreateDirectory(outputPath);
    }
    
    var files = Directory.GetFiles(entitiesPath, "*.cs");
    
    foreach (var file in files)
    {
        var entityName = Path.GetFileNameWithoutExtension(file);
        var lines = File.ReadAllLines(file);
        
        List<(string Type, string Name)> keyProperties = new();
        bool nextIsKey = false;
        bool isKeyless = lines.Any(l => l.Trim().StartsWith("[Keyless]"));
        
        foreach (var line in lines)
        {
            string trimmed = line.Trim();
            if (trimmed.StartsWith("[Key]"))
            {
                nextIsKey = true;
                continue;
            }
            if (nextIsKey && trimmed.StartsWith("public") && trimmed.Contains("{ get;") && !trimmed.Contains("class"))
            {
                var parts = trimmed.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length >= 3)
                {
                    string type = parts[1];
                    string name = parts[2];
                    if (name.Contains("{")) name = name.Substring(0, name.IndexOf("{"));
                    if (name.EndsWith(";")) name = name.Substring(0, name.Length - 1);
                    keyProperties.Add((type, name));
                }
                nextIsKey = false;
            }
        }
        
        // Generar el contenido de la clase de servicio
        string serviceContent = GenerateServiceClass(entityName, keyProperties, isKeyless);
        
        // Nombre del archivo de salida
        string outputFileName = $"{entityName}Service.cs";
        string outputFilePath = Path.Combine(outputPath, outputFileName);
        
        // Verificar si el archivo ya existe antes de escribirlo
        if (!File.Exists(outputFilePath))
        {
            File.WriteAllText(outputFilePath, serviceContent);
        }
    }
#>
// Esta plantilla ha generado clases de servicio individuales para cada entidad.
// Los archivos generados se encuentran en la carpeta GeneratedServices.
// Nota: Los archivos existentes no han sido sobrescritos.